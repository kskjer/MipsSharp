using Microsoft.VisualStudio.TestTools.UnitTesting;
using MipsSharp.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MipsSharp.Tests
{
    [TestClass]
    public class EucJpTests
    {
        [TestMethod]
        public void TestCharacterDetection()
        {
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x09 }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x0A }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x0D }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x20 }, 0).IsValid);
            Assert.IsFalse(EucJp.IsValidChar(new byte[] { 0x20 }, 0).IsEucJp);

            for (byte i = 0x0E; i < 0x20; i++)
                Assert.IsFalse(EucJp.IsValidChar(new byte[] { i }, 0).IsValid);

            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x21 }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x7E }, 0).IsValid);
            Assert.IsFalse(EucJp.IsValidChar(new byte[] { 0x7F }, 0).IsValid);
            Assert.IsFalse(EucJp.IsValidChar(new byte[] { 0x7e }, 0).IsEucJp);

            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x8E, 0xA1 }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x8E, 0xDF }, 0).IsValid);
            Assert.IsFalse(EucJp.IsValidChar(new byte[] { 0x8E, 0xE0 }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x8E, 0xDF }, 0).IsEucJp);

            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0xA1, 0xA1 }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0xFE, 0xFE }, 0).IsValid);
            Assert.IsFalse(EucJp.IsValidChar(new byte[] { 0xFF, 0xFE }, 0).IsValid);
            Assert.IsFalse(EucJp.IsValidChar(new byte[] { 0xFE, 0xFF }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0xFE, 0xFE }, 0).IsEucJp);

            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x8F, 0xA1, 0xA1 }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x8F, 0xFE, 0xFE }, 0).IsValid);
            Assert.IsFalse(EucJp.IsValidChar(new byte[] { 0x8F, 0xFF, 0xFF }, 0).IsValid);
            Assert.IsTrue(EucJp.IsValidChar(new byte[] { 0x8F, 0xFE, 0xFE }, 0).IsEucJp);
        }

        [TestMethod]
        public void TestStringExtraction()
        {
            var source = new byte[]
            {
                // from map select
                0x36, 0x37, 0x3A, 0x8D, 0x8E, 0xD6, 0x8E, 0xB3, 0x8E, 0xBE, 0x8E, 0xB2, 0x8E, 0xC9, 0x8E, 0xB7,
                0x8E, 0xC9, 0x20, 0x8C, 0x8E, 0xC0, 0x8E, 0xDE, 0x8E, 0xDD, 0x8E, 0xBC, 0x8E, 0xDE, 0x8E, 0xAE,
                0x8E, 0xDD, 0x20, 0x8E, 0xCE, 0x8E, 0xDE, 0x8E, 0xBD, 0x00, 0x00, 0x00, 0x36, 0x38, 0x3A, 0x8C,
                0x8E, 0xC4, 0x8E, 0xDE, 0x8E, 0xC4, 0x8E, 0xDE, 0x8E, 0xDD, 0x8E, 0xBA, 0x8E, 0xDE, 0x20, 0x8E,
                0xC0, 0x8E, 0xDE, 0x8E, 0xDD, 0x8E, 0xBC, 0x8E, 0xDE, 0x8E, 0xAE, 0x8E, 0xDD, 0x00, 0x00, 0x00,
                0x36, 0x39, 0x3A, 0x8C, 0x8E, 0xC4, 0x8E, 0xDE, 0x8E, 0xC4, 0x8E, 0xDE, 0x8E, 0xDD, 0x8E, 0xBA,
                0x8E, 0xDE, 0x20, 0x8E, 0xC0, 0x8E, 0xDE, 0x8E, 0xDD, 0x8E, 0xBC, 0x8E, 0xDE, 0x8E, 0xAE, 0x8E,
                0xDD, 0x20, 0x8E, 0xCE, 0x8E, 0xDE, 0x8E, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x37, 0x30, 0x3A, 0x8D,
                0x8E, 0xB7, 0x8E, 0xAE, 0x8E, 0xC0, 0x8E, 0xDE, 0x8E, 0xB2, 0x8E, 0xB7, 0x8E, 0xDE, 0x8E, 0xAE,
                0x20, 0x8C, 0x8E, 0xC0, 0x8E, 0xDE, 0x8E, 0xDD, 0x8E, 0xBC, 0x8E, 0xDE, 0x8E, 0xAE, 0x8E, 0xDD,
                0x00, 0x00, 0x00, 0x00, 0x37, 0x31, 0x3A, 0x8D, 0x8E, 0xB7, 0x8E, 0xAE, 0x8E, 0xC0, 0x8E, 0xDE,
                0x8E, 0xB2, 0x8E, 0xB7, 0x8E, 0xDE, 0x8E, 0xAE, 0x20, 0x8C, 0x8E, 0xC0, 0x8E, 0xDE, 0x8E, 0xDD,
                0x8E, 0xBC, 0x8E, 0xDE, 0x8E, 0xAE, 0x8E, 0xDD, 0x20, 0x8E, 0xCE, 0x8E, 0xDE, 0x8E, 0xBD, 0x00,
                
                // from code
                0xA5, 0xD5, 0xA5, 0xA9, 0xA5, 0xEB, 0xA5, 0xC8, 0xA5, 0xDE, 0xA5, 0xCD, 0xA1, 0xBC, 0xA5, 0xB8,
                0xA5, 0xE3, 0x3A, 0xC9, 0xD4, 0xCC, 0xC0, 0xA4, 0xCA, 0xA5, 0xE1, 0xA5, 0xC3, 0xA5, 0xBB, 0xA1,
                0xBC, 0xA5, 0xB8, 0xA4, 0xF2, 0xBC, 0xF5, 0xBF, 0xAE, 0xA4, 0xB7, 0xA4, 0xDE, 0xA4, 0xB7, 0xA4,
                0xBF, 0x0A, 0x00,
        };

            var results = EucJp.ExtractEucJpStrings(source, EucJp.AsciiColorCode, EucJp.UnknownExtraChars)
                .ToArray();

            Assert.AreEqual("67:ﾖｳｾｲﾉｷﾉ ﾀﾞﾝｼﾞｮﾝ ﾎﾞｽ", results[0].String);
            Assert.AreEqual("68:ﾄﾞﾄﾞﾝｺﾞ ﾀﾞﾝｼﾞｮﾝ", results[1].String);
            Assert.AreEqual("69:ﾄﾞﾄﾞﾝｺﾞ ﾀﾞﾝｼﾞｮﾝ ﾎﾞｽ", results[2].String);
            Assert.AreEqual("70:ｷｮﾀﾞｲｷﾞｮ ﾀﾞﾝｼﾞｮﾝ", results[3].String);
            Assert.AreEqual("71:ｷｮﾀﾞｲｷﾞｮ ﾀﾞﾝｼﾞｮﾝ ﾎﾞｽ", results[4].String);
            Assert.AreEqual("フォルトマネージャ:不明なメッセージを受信しました\n", results[5].String);

            Assert.IsTrue(results.All(x => x.ContainsEucJpCharacters));
        }
    }
}
